kubectl apply -f envoy-config.yaml
kubectl apply -f envoy-deployment.yaml
kubectl apply -f nginx-dep-ser.yaml
kubectl apply -f httpbin-dep-ser.yaml


#Get nodeport for Envoy
kubectl get svc envoy

#test without JWT
--should fail
curl -v http://<NODE_IP>:31000/httpbin/get

#Create a Dummy JWT/self-signed JWT

--we can use HS256 (symmetric key)
# Install jwt-cli if you don't have it
sudo apt update
---Installation---
--Via Node Version Manager
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
source ~/.bashrc
nvm install --lts
nvm use --lts

node -v
npm -v

pip install pyjwt

-------------------------------------
Token Generation:
python3 - <<'EOF'
import jwt, datetime
secret = "testsecret"
payload = {
    "sub": "123",
    "role": "admin",
    "iss": "test-issuer",
    "iat": datetime.datetime.utcnow(),
    "exp": datetime.datetime.utcnow() + datetime.timedelta(hours=1)
}
print(jwt.encode(payload, secret, algorithm="HS256"))
EOF

Token: xxxx
-----------
kubectl get nodes -o wide

--request without token.
/deployments_aj/deployments-aut$ curl -v http://192.168.49.2:31000/httpbin/get
*   Trying 192.168.49.2:31000...
* Connected to 192.168.49.2 (192.168.49.2) port 31000 (#0)
> GET /httpbin/get HTTP/1.1
> Host: 192.168.49.2:31000
> User-Agent: curl/7.81.0
> Accept: */*
>
* Mark bundle as not supporting multiuse
< HTTP/1.1 401 Unauthorized
< www-authenticate: Bearer realm="http://192.168.49.2:31000/httpbin/get"

--------
#Send a request with JWT token
--httpbin
#with token
curl -v -H "Authorization: Bearer eyJ0eXAiOiJKV1QiL.....ZA" http://192.168.49.2:31000/httpbin/get
*   Trying 192.168.49.2:31000...
* Connected to 192.168.49.2 (192.168.49.2) port 31000 (#0)
> GET /httpbin/get HTTP/1.1
> Host: 192.168.49.2:31000
> User-Agent: curl/7.81.0
> Accept: */*
> Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOi...ZA
>
* Mark bundle as not supporting multiuse
< HTTP/1.1 200 OK
----------

Without token → Envoy rejects (401).
With dummy token → Envoy allows access.

For nginx
curl -v http://<NODE_IP>:31000/nginx/
--should fail and show 401 authorized
curl -v -H "Authorization: Bearer <TOKEN>" http://<NODE_IP>:31000/nginx/

ubuntu@ip-172-31-46-4:~$ curl -v -H "Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOi..3ZA" http://192.168.49.2:31000/nginx
*   Trying 192.168.49.2:31000...
* Connected to 192.168.49.2 (192.168.49.2) port 31000 (#0)
> GET /nginx HTTP/1.1
> Host: 192.168.49.2:31000
> User-Agent: curl/7.81.0
> Accept: */*
> Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhb..J3ZA
>
* Mark bundle as not supporting multiuse
< HTTP/1.1 200 OK
< server: envoy
----------------------------

--check metrics
curl http://<NODE_IP>:31901/stats | grep jwt
should show
http.ingress_http.jwt_authn.dummy_provider.allowed: 5
http.ingress_http.jwt_authn.dummy_provider.denied: 3

-----------sample output--------

ubuntu@ip-172-31-46-4:~$ curl -v http://192.168.49.2:31901/stats | grep jwt
*   Trying 192.168.49.2:31901...
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0* 
  Connected to 192.168.49.2 (192.168.49.2) port 31901 (#0)
> GET /stats HTTP/1.1
> Host: 192.168.49.2:31901
> User-Agent: curl/7.81.0
> Accept: */*
>
* Mark bundle as not supporting multiuse
< HTTP/1.1 200 OK
< content-type: text/plain; charset=UTF-8
< cache-control: no-cache, max-age=0
...
http.ingress_http.jwt_authn.cors_preflight_bypassed: 0
26http.ingress_http.jwt_authn.denied: 5
.1http.ingress_http.jwt_authn.jwks_fetch_failed: 0
Mhttp.ingress_http.jwt_authn.jwks_fetch_success: 0

http.ingress_http.jwt_authn.jwt_cache_hit: 0
*http.ingress_http.jwt_authn.jwt_cache_miss: 6

--------------sample output ends-----------

--Inspect headers
--To confirm the JWT is forwarded to your backend
sudo apt install jq
curl -s -H "Authorization: Bearer <TOKEN>" http://<NODE_IP>:31000/httpbin/headers | jq .

Shows Authorization header
---------------sample output------------
ubuntu@ip-172-31-46-4:~$ curl -v -H "Authorization: Bearer eyJ0eXAiOiJ..9MWcJ3ZA" http://192.168.49.2:31000/httpbin/headers | jq .
*   Trying 192.168.49.2:31000...
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0* 
  Connected to 192.168.49.2 (192.168.49.2) port 31000 (#0)
> GET /httpbin/headers HTTP/1.1
> Host: 192.168.49.2:31000
> User-Agent: curl/7.81.0
> Accept: */*
> Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciO..c_9MWcJ3ZA
>
* Mark bundle as not supporting multiuse
< HTTP/1.1 200 OK
...
{
  "headers": {
    "Accept": "*/*",
    "Authorization": "Bearer eyJ0eXAiOiJKV1Q...kpAFJ_rmgic_9MWcJ3ZA",
    "Host": "192.168.49.2",
    "User-Agent": "curl/7.81.0",
    "X-Amzn-Trace-Id": "Root=1-68cd0870-7c004c111a719c4646873a87",
    "X-Envoy-Expected-Rq-Timeout-Ms": "15000",
    "X-Envoy-Original-Path": "/httpbin/headers"
  }
}

--------------------------------------

-------------
#Config with JWT + RBAC
jwt_authn filter validates the JWT.
If valid, the claims are added to request metadata (jwt_payload).

rbac filter then checks:
/httpbin → any authenticated user passes.
/nginx → only JWTs with "role": "admin" claim are allowed.

#Token Generation
python3 - <<'EOF'
import jwt, datetime
secret = "testsecret"
payload = {
    "sub": "123",
    "role": "admin",
    "iss": "test-issuer",
    "iat": datetime.datetime.utcnow(),
    "exp": datetime.datetime.utcnow() + datetime.timedelta(hours=1)
}
print(jwt.encode(payload, secret, algorithm="HS256"))
EOF

---to decode jwt token------
python3 - <<'EOF'
import jwt
token = "eyJ0eXAiOiJKV1QiLCJhbG...bItkYbCrCBuzE"
print(jwt.decode(token, "testsecret", algorithms=["HS256"]))
EOF

---------------------------
Similarly we can create token for a different user and test
--Access Nginx as user
curl -v -H "Authorization: Bearer <USER_TOKEN>" http://<NODE_IP>:31000/nginx/
<denied>

--Access Nginx as admin
curl -v -H "Authorization: Bearer <ADMIN_TOKEN>" http://<NODE_IP>:31000/nginx/

--Access httpbin as any user
curl -v -H "Authorization: Bearer <USER_TOKEN>" http://<NODE_IP>:31000/httpbin/get

-------------------------------
#Metrics that can be collected
Envoy’s RBAC filter provides these stats (per stat_prefix, here ingress_http):

http.ingress_http.rbac.allowed → number of requests allowed by RBAC
http.ingress_http.rbac.denied → number of requests denied by RBAC

JWT stats remain available too:

http.ingress_http.jwt_authn.dummy_provider.allowed
http.ingress_http.jwt_authn.dummy_provider.denied

--Check metrics
curl http://<NODE_IP>:31901/stats | grep rbac
curl http://<NODE_IP>:31901/stats | grep jwt

Thus, we can test
JWT-level failures (bad/missing tokens) vs RBAC-level failures (token valid, but not enough privileges).

-------------
(To verify)
#per-JWT local rate limiting still requires using RLS, not local_ratelimit
#local_ratelimit can Limit requests based on static descriptors only:

descriptors:
  - entries:
      - key: "httpbin_global"
        value: "limit"


This will count all requests together, not per-user.

----------------------------
#Global rate limiting
#Per-user / per-JWT rate limiting solution

Use Envoy + Rate Limit Service (RLS):

JWT filter → extracts claims
RLS filter → calls external RLS service with metadata (jwt_payload.sub)
RLS service applies per-user rate limits and returns allowed/denied

Generate token:
python3 - <<'EOF'
import jwt, datetime

secret = "testsecret"
payload = {
    "sub": "123",            # user ID
    "role": "admin",         # role for RBAC
    "iss": "test-issuer",    # issuer
    "iat": datetime.datetime.utcnow(),
    "exp": datetime.datetime.utcnow() + datetime.timedelta(hours=1)
}

token = jwt.encode(payload, secret, algorithm="HS256")
print(token)
EOF

eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxMjMiLCJyb2xlIjoiYWRtaW4iLCJpc3MiOiJ0ZXN0LWlzc3VlciIsImlhdCI6MTc1ODI3NjQwNiwiZXhwIjoxNzU4MjgwMDA2fQ.ffvmMnuveSSYI5NHUaKZJDv4MB0ZroiwBEvWlViAx2c

curl -v -H "Authorization: Bearer <YOUR_JWT>" http://<ENVOY_IP>:10000/httpbin/get

curl -v -H "Authorization: Bearer <YOUR_JWT>" http://<ENVOY_IP>:10000/nginx

#Observe Rate Limiting Headers

Our global rate limit is enabled via ratelimit filter. Envoy adds headers like:
x-envoy-rate-limit-remaining → requests left in the current window
x-envoy-rate-limit-reset → time to reset (seconds)

for i in {1..5}; do
> curl -v -H "Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxMjMiLCJyb2xlIjoiYWRtaW4iLCJpc3MiOiJ0ZXN0LWlzc3VlciIsImlhdCI6MTc1ODI3NjQwNiwiZXhwIjoxNzU4MjgwMDA2fQ.ffvmMnuveSSYI5NHUaKZJDv4MB0ZroiwBEvWlViAx2c" http://192.168.49.2:31000/httpbin/get
done


